<!doctype html><html lang=zh><head><meta name=viewport content="width=device-width,initial-scale=1"><title>TS类相关知识</title>
<meta charset=utf-8><meta name=description content="Ladder@TS"><meta name=author content="陈子进"><link rel=canonical href=https://juseyanwu.github.io/blog/typescript/><link rel=alternate type=application/rss+xml href=https://juseyanwu.github.io/index.xml title=陈子进><script async defer data-website-id=ec55b2da-4f55-45ef-8aed-26e57078fd15 src=https://umami-jlwf.vercel.app/hugo-ladder></script><meta property="og:title" content="TS类相关知识"><meta property="og:description" content="TS"><meta property="og:type" content="article"><meta property="og:url" content="https://juseyanwu.github.io/blog/typescript/"><meta property="article:section" content="blog"><meta property="article:published_time" content="2025-02-12T00:28:34+08:00"><meta property="article:modified_time" content="2025-02-12T00:28:34+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="TS类相关知识"><meta name=twitter:description content="TS"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Blogs","item":"https://juseyanwu.github.io/blog/"},{"@type":"ListItem","position":3,"name":"TS类相关知识","item":"https://juseyanwu.github.io/blog/typescript/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"TS类相关知识","name":"TS类相关知识","description":"TS\n","keywords":["ts"],"articleBody":"TS\n类相关 override 子类 要重写父类方法的话 加一个 override\n这个好处在于假设拼错了单词 typescript会发现并且报错\n属性修饰符 public 可以被 类内部 子类 类外部访问\n属性默认是pubilc\n这种情况就是在类的内部可以访问属性\n这种代表可以在子类被访问\n这样代表 类的外部可以访问这些public属性\n属性的简写形式 protected修饰符 类的内部，子类可以访问，外部不可以访问\nprivate修饰符 只能在类的内部使用\nreadonly修饰符 只读属性，不可以修改\n抽象类 抽象类 不能实例化其意义是可以被继承，抽象类里面可以有普通方法，也可以有抽象方法\n啥时候使用抽象类？\n定义通用接口： 为一组相关的类定义通用的行为时 提供基础实现：在抽象类中提供某些方法或为其提供基础实现，这样派生类就可以继承这些实现 确保关键实现： 如果子类继承抽象类后没有实现抽象方法，则会报错 interface（接口） 定义类的结构 表示这个类实现了这个接口（按照接口的规范来）\nimplements！！！\n定义对象的结构 把接口当成一种类型了，直接 user**：**UserInterface\n定义函数的结构 接口之间是可以继承的 接口的自动合并 也叫可以重复定义接口\n何时使用接口？ 定义对象的格式 无脑冲 类的契约：规定类需要哪些属性和方法 自动合并：扩展第三方库的类型，在一些超大型项目中使用 一些相似概念的区别 interface和type的区别 相同点： interface和type都可以用于定义对象结构，两者在许多场景中都是可以互换的 不同点： interface更专注定义对象和类的结构，支持继承、合并 type可以定义类型别名、联合类型、交叉类型、但不支持继承和自动合并 这个就是type 定义 类型别名 的例子\nType支持联合类型 和 交叉类型\ninterface和抽象类的区别 相同点： 都用于定义一个类的格式 不同点： 接口：只能描述结构，不能有任何的代码实现，一个类可以实现多个接口 抽象类： 既可以包含抽象方法，也可以包含具体方法，一个类只能继承一个抽象类 这是一个类能实现多个接口的例子\n泛型 泛型允许我们在定义函数，类或接口时，使用类型参数来表示未指定的类型，这些参数在具体使用时，才被指定具体的类型，泛型能让同一段代码适用于多种类型，同时仍然保持类型的安全性\n也可以多个\n泛型接口 类型声明文件 通常以.d.ts结尾\n作用是为 现有的js代码提供类型信息\n使得ts在使用这些老的js库或者模块时进行类型检查和提示\n","wordCount":"83","inLanguage":"zh","datePublished":"2025-02-12T00:28:34+08:00","dateModified":"2025-02-12T00:28:34+08:00","author":{"@type":"Person","name":"陈子进"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://juseyanwu.github.io/blog/typescript/"},"publisher":{"@type":"Organization","name":"陈子进","logo":{"@type":"ImageObject","url":"https://juseyanwu.github.io/favicon.ico"}}}</script><link rel=icon href=/images/1.png sizes=16x16><link rel=apple-touch-icon href=/images/1.png><link rel=manifest href=/images/1.png><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-webfont@1.7.0/style.css><link rel=stylesheet href=/css/main.min.ec28f09e946fc0df77c187fcd0d0ebde58fca6de8efb8e1620f3d45c32d4da88.css integrity="sha256-7CjwnpRvwN93wYf80NDr3lj8pt6O+44WIPPUXDLU2og=" crossorigin=anonymous media=screen><link rel=stylesheet href=/scss/highlight/github-dark.min.min.66034289ee9a113219a2c4aae0a8bd2095ab255c832a42efcf5863f10814e7a1.css><script src=/js/highlight.min.min.894ca9c68afab956438c4926a0dc7f5293e04e08595bd27abdb123e94801f684.js></script><script>hljs.highlightAll()</script><script>(()=>{var t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,e=localStorage.getItem("theme");t&&e===null&&(localStorage.setItem("theme","dark"),document.documentElement.setAttribute("data-dark-mode","")),t&&e==="dark"&&document.documentElement.setAttribute("data-dark-mode",""),e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script></head><body><main class=wrapper><nav class=navigation><section class=container><a class=navigation-brand href=/>主页
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><span></span><span></span><span></span></label><ul class=navigation-list id=navigation-list><li class="navigation-item navigation-menu"><a class=navigation-link href=/blog/>文章</a></li><li class="navigation-item navigation-menu"><a class=navigation-link href=/tags/>分类</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class="navigation-item navigation-social"><a class=navigation-link href=https://github.com/juseyanwu><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-github"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37.0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44.0 0020 4.77 5.07 5.07.0 0019.91 1S18.73.65 16 2.48a13.38 13.38.0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07.0 005 4.77 5.44 5.44.0 003.5 8.55c0 5.42 3.3 6.61 6.44 7A3.37 3.37.0 009 18.13V22"/></svg></a></li><li class="navigation-item navigation-dark"><button id=mode type=button aria-label="toggle user light or dark theme">
<span class=toggle-dark><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg></span><span class=toggle-light><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></span></button></li></ul></section></nav><div id=content><article class=blog-single><header class=blog-title><h1>TS类相关知识</h1></header><p><small>2025年2月12日&nbsp;· 83 字&nbsp;· 1 分钟</small><p><div class=blog-toc><nav id=TableOfContents><ul><li><a href=#类相关>类相关</a><ul><li><a href=#override>override</a></li><li><a href=#属性修饰符>属性修饰符</a></li><li><a href=#属性的简写形式>属性的简写形式</a></li><li><a href=#protected修饰符>protected修饰符</a></li><li><a href=#private修饰符>private修饰符</a></li><li><a href=#readonly修饰符>readonly修饰符</a></li><li><a href=#抽象类>抽象类</a></li></ul></li><li><a href=#interface接口>interface（接口）</a><ul><li><a href=#定义类的结构>定义类的结构</a></li><li><a href=#定义对象的结构>定义对象的结构</a></li><li><a href=#定义函数的结构>定义函数的结构</a></li><li><a href=#接口之间是可以继承的>接口之间是可以继承的</a></li><li><a href=#接口的自动合并>接口的自动合并</a></li><li><a href=#何时使用接口>何时使用接口？</a></li></ul></li><li><a href=#一些相似概念的区别>一些相似概念的区别</a><ul><li><a href=#interface和type的区别>interface和type的区别</a></li><li><a href=#interface和抽象类的区别>interface和抽象类的区别</a></li></ul></li><li><a href=#泛型>泛型</a><ul><li><a href=#泛型接口>泛型接口</a></li><li><a href=#类型声明文件>类型声明文件</a></li></ul></li></ul></nav></div><section class=blog-content><p>TS</p><h2 id=类相关>类相关</h2><h3 id=override>override</h3><p>子类 要重写父类方法的话 加一个 <strong>override</strong></p><p><img src=/images/image-20250206024431993.png alt=image-20250206024431993></p><p>这个好处在于假设拼错了单词 typescript会发现并且报错</p><h3 id=属性修饰符>属性修饰符</h3><h4 id=public>public</h4><p>可以被 类内部 子类 类外部访问</p><p><img src=/images/image-20250206024736719.png alt=images-20250206024736719></p><p>属性默认是pubilc</p><p>这种情况就是在类的内部可以访问属性</p><p><img src=/images/image-20250206024815652.png alt=images-20250206024815652></p><p>这种代表可以在子类被访问</p><p><img src=/images/image-20250206024917044.png alt=images-20250206024917044></p><p>这样代表 类的外部可以访问这些public属性</p><h3 id=属性的简写形式>属性的简写形式</h3><p><img src=/images/image-20250206025025128.png alt=images-20250206025025128></p><h3 id=protected修饰符>protected修饰符</h3><p>类的内部，子类可以访问，外部不可以访问</p><h3 id=private修饰符>private修饰符</h3><p>只能在类的内部使用</p><h3 id=readonly修饰符>readonly修饰符</h3><p><img src=/images/image-20250206025454049.png alt=images-20250206025454049></p><p>只读属性，不可以修改</p><h3 id=抽象类>抽象类</h3><p>抽象类 不能<strong>实例化</strong>其意义是<strong>可以被继承</strong>，抽象类里面可以有<strong>普通方法</strong>，也可以有<strong>抽象方法</strong></p><p><img src=/images/image-20250206030425580.png alt=images-20250206030425580></p><p>啥时候使用抽象类？</p><ul><li>定义通用接口： 为一组相关的类定义通用的行为时</li><li>提供基础实现：在抽象类中提供某些方法或为其提供基础实现，这样派生类就可以继承这些实现</li><li>确保关键实现： 如果子类继承抽象类后没有实现抽象方法，则会报错</li></ul><h2 id=interface接口>interface（接口）</h2><h3 id=定义类的结构>定义类的结构</h3><p><img src=/images/image-20250206031224090.png alt=images-20250206031224090></p><p>表示这个类实现了这个接口（按照接口的规范来）</p><p>implements！！！</p><h3 id=定义对象的结构>定义对象的结构</h3><p><img src=/images/image-20250206031522226.png alt=images-20250206031522226></p><p>把接口当成一种类型了，直接 user**：**UserInterface</p><h3 id=定义函数的结构>定义函数的结构</h3><p><img src=/images/image-20250206031703480.png alt=images-20250206031703480></p><h3 id=接口之间是可以继承的>接口之间是可以继承的</h3><p><img src=/images/image-20250206031801122.png alt=images-20250206031801122></p><h3 id=接口的自动合并>接口的自动合并</h3><p><img src=/images/image-20250206031907096.png alt=images-20250206031907096></p><p>也叫可以重复定义接口</p><h3 id=何时使用接口>何时使用接口？</h3><ul><li>定义对象的格式 无脑冲</li><li>类的契约：规定类需要哪些属性和方法</li><li>自动合并：扩展第三方库的类型，在一些超大型项目中使用</li></ul><h2 id=一些相似概念的区别>一些相似概念的区别</h2><h3 id=interface和type的区别>interface和type的区别</h3><ul><li>相同点： interface和type都可以用于<strong>定义对象结构</strong>，两者在许多场景中都是可以互换的</li><li>不同点：<ul><li>interface更专注定义<strong>对象</strong>和<strong>类</strong>的结构，支持<strong>继承、合并</strong></li><li>type可以定义<strong>类型别名、联合类型、交叉类型、但不支持继承和自动合并</strong></li></ul></li></ul><p><img src=/images/image-20250206032452737.png alt=images-20250206032452737></p><p>这个就是type 定义 <strong>类型别名</strong> 的例子</p><p><img src=/images/image-20250206032531008.png alt=images-20250206032531008></p><p>Type支持<strong>联合类型</strong> 和 <strong>交叉类型</strong></p><h3 id=interface和抽象类的区别>interface和抽象类的区别</h3><ul><li>相同点： 都用于定义一个类的格式</li><li>不同点：<ul><li>接口：只能描述结构，不能有任何的代码实现，一个类可以实现多个接口</li><li>抽象类： 既可以包含抽象方法，也可以包含具体方法，一个类只能继承一个抽象类</li></ul></li></ul><p><img src=/images/image-20250206033009028.png alt=images-20250206033009028></p><p>这是一个类能实现多个接口的例子</p><h2 id=泛型>泛型</h2><p>泛型允许我们在定义函数，类或接口时，使用类型参数来表示未指定的类型，这些参数在具体使用时，才被指定具体的类型，泛型能让同一段代码适用于多种类型，同时仍然保持类型的安全性</p><p><img src=/images/image-20250206033404133.png alt=images-20250206033404133></p><p><img src=/images/image-20250206033449756.png alt=images-20250206033449756></p><p>也可以多个</p><h3 id=泛型接口>泛型接口</h3><p><img src=/images/image-20250206033545753.png alt=images-20250206033545753></p><p><img src=/images/image-20250206033640780.png alt=images-20250206033640780></p><h3 id=类型声明文件>类型声明文件</h3><p>通常以.d.ts结尾</p><p>作用是为 <strong>现有的js代码提供类型信息</strong></p><p>使得ts在使用这些老的js库或者模块时进行<strong>类型检查和提示</strong></p></section><div class=paginator><a class=prev href=https://juseyanwu.github.io/blog/css/><svg class="icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3.77086 21.1546C11.0491 22.698 21.4339 21.7773 21.4339 16.3608V4.63375c0-.69413-.075800000000001-1.3284-.2422-1.86588M3.77086 21.1546C1.9934 20.7777.973585 18.7264 1.08749 16.688c.17931-3.209.06972-7.25665-.08236-10.47293C.87809 3.52811 3.12891 1.16316 5.51029 1.25008c4.25565.15534 9.86671-.04779 13.28091-.24466 1.2952-.074686 2.0494.62843 2.4005 1.76245M3.77086 21.1546C4.56586 21.4723 5.49168 21.7879 6.5 22.0658M21.1917 2.76787c1.918 1.4143 1.9383 9.65123 1.7087 13.59293-2.0526 7.6586-10.5943 7.3054-16.4004 5.705M21.1917 2.76787C21.7612 4.51192 22.7203 9.67216 22 16.3608 21.2797 23.0494 11.3665 22.9511 6.5 22.0658M9.94496 9C9.28897 9.61644 7.63215 10.997 6.04814 11.7966 5.98257 11.8297 5.98456 11.9753 6.05061 12.0063c1.00435.4716 2.8788 1.9201 3.89435 2.9937M6.44444 11.9667C8.86549 12.0608 14 12 16 11" stroke="currentcolor" stroke-linecap="round"/></svg><span>css相关知识</span></a></div></article></div><footer class=footer><p>&copy; 2025 <a href=https://juseyanwu.github.io>陈子进</a>
Powered by
<a href=https://gohugo.io/ rel=noopener target=_blank>Hugo️️</a>
<a href=https://github.com/guangzhengli/hugo-theme-ladder rel=noopener target=_blank>Ladder</a>
️</p></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M10.5376 22.7916C11.0152 22.7207 22.5795 21.1781 22.0978 10.4211 22.0536 9.43274 21.9303 8.53367 21.7387 7.71865M10.5376 22.7916C16.876 22.3728 20.0969 19.8899 21.5383 16.9142M10.5376 22.7916C9.7707 22.9055 8.97982 22.8964 8.19743 22.7725M21.7387 7.71865C21.4988 6.69828 21.1518 5.80967 20.7188 5.04257m1.0199 2.67608C22.6022 10.1105 23.0542 13.7848 21.5383 16.9142M20.7188 5.04257c-3.5504-6.28886-12.88753-4.410077-16.44303.0C2.88063 6.77451-.0433281 11.1668 1.38159 16.6571c.89322 3.4417 3.7911 5.6365 6.81584 6.1154M20.7188 5.04257c1.3509 1.89783 3.3111 6.34223 1.6353 10.37273M21.5383 16.9142C21.8737 16.4251 22.1428 15.9235 22.3541 15.4153M8.19743 22.7725C12.1971 23.4683 20.6281 22.971 22.3541 15.4153M14 10.945C13.3836 10.289 12.003 8.63215 11.2034 7.04814 11.1703 6.98257 11.0247 6.98456 10.9937 7.05061 10.5221 8.05496 9.07362 9.92941 8 10.945m3.0333-3.50056C10.9392 9.86549 11 15 12 17" stroke="currentcolor" stroke-linecap="round"/></svg></a><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const s=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="Copy";function n(){t.innerHTML="Copied",setTimeout(()=>{t.innerHTML="Copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),n();return}const s=document.createRange();s.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(s);try{document.execCommand("copy"),n()}catch{}o.removeRange(s)}),e.parentNode.appendChild(t)})</script></main></body><script src=/main.min.6bb26b69159420159c74dc9e097b06a578ed2b68c701466a91a44a9632d851bd0af167a1b30012387b4c512b48ad9ad4d3394e04d77ae38d57e1920fe4ed34fe.js integrity="sha512-a7JraRWUIBWcdNyeCXsGpXjtK2jHAUZqkaRKljLYUb0K8WehswASOHtMUStIrZrU0zlOBNd6441X4ZIP5O00/g==" crossorigin=anonymous defer></script></html>