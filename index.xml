<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>陈子进</title><link>https://juseyanwu.github.io/</link><description>Recent content on 陈子进 created by</description><generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Fri, 28 Feb 2025 00:28:34 +0800</lastBuildDate><atom:link href="https://juseyanwu.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>css相关知识</title><link>https://juseyanwu.github.io/blog/css/</link><pubDate>Fri, 28 Feb 2025 00:28:34 +0800</pubDate><guid>https://juseyanwu.github.io/blog/css/</guid><description>&lt;p>TS&lt;/p>
&lt;h1 id="css">css&lt;/h1>
&lt;h3 id="css盒模型">css盒模型&lt;/h3>
&lt;ul>
&lt;li>是什么： 浏览器渲染一个容器时，会把容器渲染成四个区域，分别为 content padding border margin，由这四个区域组成一个盒子模型&lt;/li>
&lt;li>有什么特点：
&lt;ul>
&lt;li>标准盒子模型：width 和 height 只定义 **内容区域 **的大小，内边距和边框的大小会额外添加到总宽度和总高度中。&lt;/li>
&lt;li>IE盒子模型：将 width 和 height 定义为包括 内容区域、内边距、边框 的总和&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>使用 box-sizing: border-box 可以强制浏览器使用标准盒模型&lt;/li>
&lt;/ul>
&lt;h3 id="css-选择器">css 选择器&lt;/h3>
&lt;ol>
&lt;li>基础选择器&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>元素选择器：选择制定标签的元素&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-css" data-lang="css">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">div&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">color&lt;/span>: &lt;span style="color:#66d9ef">red&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>类名选择器：选择指定的类名，类名前面加 .&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-css" data-lang="css">&lt;span style="display:flex;">&lt;span>.&lt;span style="color:#a6e22e">button&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">background-color&lt;/span>: &lt;span style="color:#66d9ef">blue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>ID选择器（#）&lt;/li>
&lt;li>通配符选择器（*）：选择页面中全部的元素&lt;/li>
&lt;/ul>
&lt;ol start="2">
&lt;li>组合选择器&lt;/li>
&lt;/ol>
&lt;ul>
&lt;li>后代选择器
&lt;ul>
&lt;li>选择某元素内部的所有子元素，不限于直接子元素，可以是任意层级的后代元素：&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-css" data-lang="css">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">div&lt;/span> &lt;span style="color:#f92672">p&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">color&lt;/span>: &lt;span style="color:#66d9ef">green&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>子元素选择器（使用 &amp;gt;）&lt;/li>
&lt;/ul>
&lt;p>这将应用于所有直接位于 &lt;!-- raw HTML omitted --> 元素下的 &lt;!-- raw HTML omitted --> 元素。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-css" data-lang="css">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">div&lt;/span> &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#f92672">p&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">color&lt;/span>: &lt;span style="color:#66d9ef">blue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>相邻兄弟选择器（使用 +）&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-css" data-lang="css">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">h1&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#f92672">p&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">color&lt;/span>: &lt;span style="color:#66d9ef">red&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这将应用于紧跟在 &lt;!-- raw HTML omitted --> 元素后的第一个 &lt;!-- raw HTML omitted --> 元素。&lt;/p>
&lt;ul>
&lt;li>通用兄弟选择器（使用～）&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-css" data-lang="css">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">h1&lt;/span> &lt;span style="color:#f92672">~&lt;/span> &lt;span style="color:#f92672">p&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">color&lt;/span>: &lt;span style="color:#66d9ef">red&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这将应用于所有位于 &lt;!-- raw HTML omitted --> 元素之后的 &lt;!-- raw HTML omitted --> 元素，无论它们之间有多少兄弟元素。&lt;/p>
&lt;ol start="3">
&lt;li>伪类选择器&lt;/li>
&lt;/ol>
&lt;p>:hover :focus&lt;/p>
&lt;p>伪类选择器用于选择处于特定状态的元素，常用于用户交互样式、动态效果等。&lt;/p>
&lt;ol start="4">
&lt;li>伪元素选择器&lt;/li>
&lt;li>属性选择器&lt;/li>
&lt;/ol>
&lt;p>[attribute=&amp;ldquo;value&amp;rdquo;]：选择拥有指定属性且属性值为指定值的元素&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-css" data-lang="css">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">input&lt;/span>&lt;span style="color:#f92672">[&lt;/span>&lt;span style="color:#f92672">type&lt;/span>&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;text&amp;#34;&lt;/span>&lt;span style="color:#f92672">]&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">background-color&lt;/span>: &lt;span style="color:#66d9ef">yellow&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>选择器优先级&lt;/li>
&lt;/ul>
&lt;p>​ • &lt;strong>ID选择器&lt;/strong>（#id）的优先级最高。&lt;/p>
&lt;p>​ • &lt;strong>类选择器&lt;/strong>（.class）和 &lt;strong>属性选择器&lt;/strong>（[type=&amp;ldquo;text&amp;rdquo;]）的优先级其次。&lt;/p>
&lt;p>​ • &lt;strong>元素选择器&lt;/strong>（div）的优先级最低。&lt;/p>
&lt;p>!important 无敌&lt;/p>
&lt;p>还有一个内联样式&lt;/p>
&lt;p>&lt;strong>!important &amp;gt; 内联 &amp;gt; id &amp;gt; 类选择器 &amp;gt; 元素选择器&lt;/strong>&lt;/p>
&lt;h3 id="说说-emremvhvw-的区别">说说 em/rem/vh/vw 的区别&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>他们都是css常用的相对单位&lt;/p>
&lt;/li>
&lt;li>
&lt;p>em：相对于声明了font-size的父元素的字体大小来计算，不仅适用于字体，也适用于margin，padding，width等&lt;/p>
&lt;/li>
&lt;li>
&lt;p>rem: 相对于根元素的字体大小&lt;/p>
&lt;/li>
&lt;li>
&lt;p>vh: 相对于视窗高度的百分比&lt;/p>
&lt;/li>
&lt;li>
&lt;p>vw：相对于视窗宽度的百分比&lt;/p>
&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>移动端适配方案： rem || 媒体查询&lt;/li>
&lt;li>pc 端适配方案：% + 媒体查询 || rem&lt;/li>
&lt;/ol>
&lt;h3 id="css当中有哪些方式可以隐藏元素区别">css当中有哪些方式可以隐藏元素？区别？&lt;/h3>
&lt;ul>
&lt;li>dispaly: none （完全从文档流中移除，不参与布局计算，不触发事件）&lt;/li>
&lt;li>Opacity: 0 （可以触发事件，仍然占据空间）&lt;/li>
&lt;li>visibility: hidden （仍然在文档流中，&lt;strong>但是不触发事件&lt;/strong>）&lt;/li>
&lt;li>Position: absolute + left: -9999px（脱离文档流，触发不到事件）&lt;/li>
&lt;li>width 0 height 0;&lt;/li>
&lt;li>overflow: hidden;&lt;/li>
&lt;li>clip-path: polygon(00, 00,00,00) 会把元素全部裁剪掉，使其不可见，但是元素占据空间&lt;/li>
&lt;li>transform: scale(0): 占据文档流，不触发事件&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;strong>方法&lt;/strong>&lt;/th>
&lt;th>&lt;strong>元素占用空间&lt;/strong>&lt;/th>
&lt;th>&lt;strong>可交互性&lt;/strong>&lt;/th>
&lt;th>&lt;strong>使用场景&lt;/strong>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>display: none&lt;/td>
&lt;td>不占空间&lt;/td>
&lt;td>不可交互&lt;/td>
&lt;td>完全移除元素，常用于动态显示隐藏&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>visibility: hidden&lt;/td>
&lt;td>占空间&lt;/td>
&lt;td>不可交互&lt;/td>
&lt;td>隐藏元素，但保留其占用空间&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>opacity: 0&lt;/td>
&lt;td>占空间&lt;/td>
&lt;td>可交互&lt;/td>
&lt;td>隐藏元素内容，但保留其交互性&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>position: absolute + left: -9999px&lt;/td>
&lt;td>占空间&lt;/td>
&lt;td>不可交互&lt;/td>
&lt;td>将元素移出视口&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>z-index: -9999&lt;/td>
&lt;td>占空间&lt;/td>
&lt;td>不可交互&lt;/td>
&lt;td>将元素隐藏在其他元素下方&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>clip-path: polygon(00,00,00,00)&lt;/td>
&lt;td>占空间&lt;/td>
&lt;td>不可交互&lt;/td>
&lt;td>通过剪切隐藏元素，常用于动画&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>overflow: hidden&lt;/td>
&lt;td>占空间&lt;/td>
&lt;td>可交互&lt;/td>
&lt;td>处理超出容器的内容&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="说说你对bfc的理解">说说你对BFC的理解&lt;/h3>
&lt;ul>
&lt;li>BFC 是什么：block formatting context，浏览器渲染的一个特殊区域，有自己独特的渲染规则，BFC容器是一个独立的布局环境，其中的子元素不会影响BFC之外的元素&lt;/li>
&lt;li>触发条件：
&lt;ul>
&lt;li>float不是 none （float：left &amp;hellip;&lt;/li>
&lt;li>position 的 absolute 或 fixed&lt;/li>
&lt;li>display 取 inline-xxx table-xxx flex grid&lt;/li>
&lt;li>overflow 取值不是visible。（hidden，auto，scroll）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>BFC的特性
&lt;ul>
&lt;li>BFC内部的元素不会影响外部元素&lt;/li>
&lt;li>BFC 内部的元素 的外边距不会与外部元素的外边距重合&lt;/li>
&lt;li>BFC计算高度时会把内部浮动元素的高度计算在内（清除浮动问题）
&lt;ul>
&lt;li>父元素如果没有height，子元素设置float之后会导致父元素高度坍塌，而BFC可以解决&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>BFC 的区域不会与浮动元素重叠，因此可以用 BFC 避免文本环绕浮动元素的情况。（假设前面一个元素float：left了，后面有一个文本，默认会环绕它，但是将文本设置成bfc的话，可以避免环绕）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="元素水平垂直居中的方法">元素水平垂直居中的方法&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>FlexBox&lt;/p>
&lt;ul>
&lt;li>display: flex; align-item: center;// 垂直居中 justify-content: center //水平居中(弹性的主轴居中)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Grid&lt;/p>
&lt;ul>
&lt;li>dispaly: grid; place-item: center;&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>position: absolute; top:50%; left:50%; transform: translate(-50%, -50%)&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-css" data-lang="css">&lt;span style="display:flex;">&lt;span>.&lt;span style="color:#a6e22e">item&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">position&lt;/span>: &lt;span style="color:#66d9ef">absolute&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">top&lt;/span>: &lt;span style="color:#ae81ff">50&lt;/span>&lt;span style="color:#66d9ef">%&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">transform&lt;/span>: translate(&lt;span style="color:#ae81ff">-50&lt;/span>&lt;span style="color:#66d9ef">%&lt;/span>, &lt;span style="color:#ae81ff">-50&lt;/span>&lt;span style="color:#66d9ef">%&lt;/span>); &lt;span style="color:#75715e">/* 向上和向左平移 50% */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>定位 + margin负值 （需要知道子容器的宽高）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>定位 + margin: auto （需要子容器有固定宽高）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>table-cell&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-css" data-lang="css">&lt;span style="display:flex;">&lt;span>.&lt;span style="color:#a6e22e">container&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">display&lt;/span>: &lt;span style="color:#66d9ef">table&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">width&lt;/span>: &lt;span style="color:#ae81ff">100&lt;/span>&lt;span style="color:#66d9ef">%&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">height&lt;/span>: &lt;span style="color:#ae81ff">100&lt;/span>&lt;span style="color:#66d9ef">vh&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>.&lt;span style="color:#a6e22e">item&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">display&lt;/span>: &lt;span style="color:#66d9ef">table-cell&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">vertical-align&lt;/span>: &lt;span style="color:#66d9ef">middle&lt;/span>; &lt;span style="color:#75715e">/* 垂直居中 */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">text-align&lt;/span>: &lt;span style="color:#66d9ef">center&lt;/span>; &lt;span style="color:#75715e">/* 水平居中 */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">width&lt;/span>: &lt;span style="color:#ae81ff">200&lt;/span>&lt;span style="color:#66d9ef">px&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">height&lt;/span>: &lt;span style="color:#ae81ff">200&lt;/span>&lt;span style="color:#66d9ef">px&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">background-color&lt;/span>: &lt;span style="color:#66d9ef">lightpink&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>三布局：flex；gird；table；三定位：+transform +auto +负值&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="说说你对css动画的理解">说说你对css动画的理解&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>transition&lt;/p>
&lt;ul>
&lt;li>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-css" data-lang="css">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">selector&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">transition&lt;/span>: property duration timing-function delay;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>• property：指定动画应用的 CSS 属性（可以是某个具体的属性，或者 all，表示所有可过渡的属性）。&lt;/p>
&lt;p>• duration：动画持续的时间，单位通常是秒（s）或毫秒（ms）。&lt;/p>
&lt;p>• timing-function：定义动画的速度曲线，控制过渡的加速度，可以使用 ease、linear、ease-in、ease-out、ease-in-out 等。&lt;/p>
&lt;p>• delay：设置动画开始的延迟时间。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>transform&lt;/p>
&lt;ul>
&lt;li>transform: rotate(45deg); // 旋转&lt;/li>
&lt;li>transform: scale(2) // 放大两倍&lt;/li>
&lt;li>transform: translateX(50px);&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Animation + keyframes&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="响应式布局的实现方式有哪些">响应式布局的实现方式有哪些？&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>根据视窗宽度来自动调节页面模块的大小和位置&lt;/p>
&lt;/li>
&lt;li>
&lt;p>媒体查询&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-css" data-lang="css">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/* 默认样式 */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>.&lt;span style="color:#a6e22e">container&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">width&lt;/span>: &lt;span style="color:#ae81ff">80&lt;/span>&lt;span style="color:#66d9ef">%&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/* 当屏幕宽度小于等于 768px 时 */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@&lt;span style="color:#66d9ef">media&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#f92672">max-width&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#f92672">768px&lt;/span>&lt;span style="color:#f92672">)&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">container&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">width&lt;/span>: &lt;span style="color:#ae81ff">100&lt;/span>&lt;span style="color:#66d9ef">%&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/* 当屏幕宽度小于等于 480px 时 */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@&lt;span style="color:#66d9ef">media&lt;/span> &lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#f92672">max-width&lt;/span>&lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#f92672">480px&lt;/span>&lt;span style="color:#f92672">)&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .&lt;span style="color:#a6e22e">container&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">width&lt;/span>: &lt;span style="color:#ae81ff">100&lt;/span>&lt;span style="color:#66d9ef">%&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">padding&lt;/span>: &lt;span style="color:#ae81ff">10&lt;/span>&lt;span style="color:#66d9ef">px&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;p>使用百分比宽度&lt;/p>
&lt;/li>
&lt;li>
&lt;p>flexbox布局&lt;/p>
&lt;/li>
&lt;li>
&lt;p>grid布局&lt;/p>
&lt;/li>
&lt;li>
&lt;p>vh/vw&lt;/p>
&lt;/li>
&lt;li>
&lt;p>max-width 和min-width&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="css-性能优化">css 性能优化&lt;/h3>
&lt;ul>
&lt;li>首页使用内联样式&lt;/li>
&lt;li>异步加载 css&lt;/li>
&lt;li>压缩&lt;/li>
&lt;li>合理使用选择器&lt;/li>
&lt;/ul>
&lt;h3 id="文本单行显示溢出则省略号">文本单行显示，溢出则省略号&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-css" data-lang="css">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">p&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">width&lt;/span>: &lt;span style="color:#ae81ff">100&lt;/span>&lt;span style="color:#66d9ef">%&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">overflow&lt;/span>: &lt;span style="color:#66d9ef">hidden&lt;/span>; &lt;span style="color:#960050;background-color:#1e0010">//超出则隐藏&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">white-space&lt;/span>: &lt;span style="color:#66d9ef">nowrap&lt;/span>; &lt;span style="color:#960050;background-color:#1e0010">//&lt;/span> &lt;span style="color:#960050;background-color:#1e0010">文本不换行&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">text-overflow&lt;/span>: &lt;span style="color:#66d9ef">ellipsis&lt;/span>; &lt;span style="color:#960050;background-color:#1e0010">//超出...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="css画三角形">css画三角形&lt;/h3>
&lt;ul>
&lt;li>利用border的特性，假设两个边框重合，一个边框transparent了，那么另一个有颜色的边框天生会被切掉一半，形成一种三角形&lt;/li>
&lt;/ul>
&lt;h3 id="聊聊-css-与处理器">聊聊 css 与处理器&lt;/h3>
&lt;ul>
&lt;li>less&lt;/li>
&lt;li>sass&lt;/li>
&lt;li>stylus&lt;/li>
&lt;/ul>
&lt;ol>
&lt;li>是一种css语言&lt;/li>
&lt;li>可以使用变量，函数，继承，混入&lt;/li>
&lt;/ol>
&lt;h3 id="flex布局">flex布局&lt;/h3>
&lt;ul>
&lt;li>弹性容器的子容器会默认继承弹性容器的100%的高度
&lt;ul>
&lt;li>继承的是交叉轴轴方向上的长度
&lt;ul>
&lt;li>假设使用flex-direction: column使得主轴变为y轴，那么内部的子容器会默认拥有弹性容器的100%的宽度（交叉轴）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>默认情况下，子容器在主轴上是不放大，会缩小的&lt;/li>
&lt;li>flex的三个参数 flex: 0 0 150px
&lt;ul>
&lt;li>第一个参数是 flex-grow （是否允许放大）默认为0&lt;/li>
&lt;li>第二个参数是flex-shrink (是否允许缩小) 默认为 1&lt;/li>
&lt;li>第三个参数是flex-basis （基准大小）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>flex-warp: warp 允许换行&lt;/li>
&lt;/ul></description></item><item><title>TS类相关知识</title><link>https://juseyanwu.github.io/blog/typescript/</link><pubDate>Wed, 12 Feb 2025 00:28:34 +0800</pubDate><guid>https://juseyanwu.github.io/blog/typescript/</guid><description>&lt;p>TS&lt;/p>
&lt;h2 id="类相关">类相关&lt;/h2>
&lt;h3 id="override">override&lt;/h3>
&lt;p>子类 要重写父类方法的话 加一个 &lt;strong>override&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://juseyanwu.github.io/images/image-20250206024431993.png" alt="image-20250206024431993">&lt;/p>
&lt;p>这个好处在于假设拼错了单词 typescript会发现并且报错&lt;/p>
&lt;h3 id="属性修饰符">属性修饰符&lt;/h3>
&lt;h4 id="public">public&lt;/h4>
&lt;p>可以被 类内部 子类 类外部访问&lt;/p>
&lt;p>&lt;img src="https://juseyanwu.github.io/images/image-20250206024736719.png" alt="images-20250206024736719">&lt;/p>
&lt;p>属性默认是pubilc&lt;/p>
&lt;p>这种情况就是在类的内部可以访问属性&lt;/p>
&lt;p>&lt;img src="https://juseyanwu.github.io/images/image-20250206024815652.png" alt="images-20250206024815652">&lt;/p>
&lt;p>这种代表可以在子类被访问&lt;/p>
&lt;p>&lt;img src="https://juseyanwu.github.io/images/image-20250206024917044.png" alt="images-20250206024917044">&lt;/p>
&lt;p>这样代表 类的外部可以访问这些public属性&lt;/p>
&lt;h3 id="属性的简写形式">属性的简写形式&lt;/h3>
&lt;p>&lt;img src="https://juseyanwu.github.io/images/image-20250206025025128.png" alt="images-20250206025025128">&lt;/p>
&lt;h3 id="protected修饰符">protected修饰符&lt;/h3>
&lt;p>类的内部，子类可以访问，外部不可以访问&lt;/p>
&lt;h3 id="private修饰符">private修饰符&lt;/h3>
&lt;p>只能在类的内部使用&lt;/p>
&lt;h3 id="readonly修饰符">readonly修饰符&lt;/h3>
&lt;p>&lt;img src="https://juseyanwu.github.io/images/image-20250206025454049.png" alt="images-20250206025454049">&lt;/p>
&lt;p>只读属性，不可以修改&lt;/p>
&lt;h3 id="抽象类">抽象类&lt;/h3>
&lt;p>抽象类 不能&lt;strong>实例化&lt;/strong>其意义是&lt;strong>可以被继承&lt;/strong>，抽象类里面可以有&lt;strong>普通方法&lt;/strong>，也可以有&lt;strong>抽象方法&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://juseyanwu.github.io/images/image-20250206030425580.png" alt="images-20250206030425580">&lt;/p>
&lt;p>啥时候使用抽象类？&lt;/p>
&lt;ul>
&lt;li>定义通用接口： 为一组相关的类定义通用的行为时&lt;/li>
&lt;li>提供基础实现：在抽象类中提供某些方法或为其提供基础实现，这样派生类就可以继承这些实现&lt;/li>
&lt;li>确保关键实现： 如果子类继承抽象类后没有实现抽象方法，则会报错&lt;/li>
&lt;/ul>
&lt;h2 id="interface接口">interface（接口）&lt;/h2>
&lt;h3 id="定义类的结构">定义类的结构&lt;/h3>
&lt;p>&lt;img src="https://juseyanwu.github.io/images/image-20250206031224090.png" alt="images-20250206031224090">&lt;/p>
&lt;p>表示这个类实现了这个接口（按照接口的规范来）&lt;/p>
&lt;p>implements！！！&lt;/p>
&lt;h3 id="定义对象的结构">定义对象的结构&lt;/h3>
&lt;p>&lt;img src="https://juseyanwu.github.io/images/image-20250206031522226.png" alt="images-20250206031522226">&lt;/p>
&lt;p>把接口当成一种类型了，直接 user**：**UserInterface&lt;/p>
&lt;h3 id="定义函数的结构">定义函数的结构&lt;/h3>
&lt;p>&lt;img src="https://juseyanwu.github.io/images/image-20250206031703480.png" alt="images-20250206031703480">&lt;/p>
&lt;h3 id="接口之间是可以继承的">接口之间是可以继承的&lt;/h3>
&lt;p>&lt;img src="https://juseyanwu.github.io/images/image-20250206031801122.png" alt="images-20250206031801122">&lt;/p>
&lt;h3 id="接口的自动合并">接口的自动合并&lt;/h3>
&lt;p>&lt;img src="https://juseyanwu.github.io/images/image-20250206031907096.png" alt="images-20250206031907096">&lt;/p>
&lt;p>也叫可以重复定义接口&lt;/p>
&lt;h3 id="何时使用接口">何时使用接口？&lt;/h3>
&lt;ul>
&lt;li>定义对象的格式 无脑冲&lt;/li>
&lt;li>类的契约：规定类需要哪些属性和方法&lt;/li>
&lt;li>自动合并：扩展第三方库的类型，在一些超大型项目中使用&lt;/li>
&lt;/ul>
&lt;h2 id="一些相似概念的区别">一些相似概念的区别&lt;/h2>
&lt;h3 id="interface和type的区别">interface和type的区别&lt;/h3>
&lt;ul>
&lt;li>相同点： interface和type都可以用于&lt;strong>定义对象结构&lt;/strong>，两者在许多场景中都是可以互换的&lt;/li>
&lt;li>不同点：
&lt;ul>
&lt;li>interface更专注定义&lt;strong>对象&lt;/strong>和&lt;strong>类&lt;/strong>的结构，支持&lt;strong>继承、合并&lt;/strong>&lt;/li>
&lt;li>type可以定义&lt;strong>类型别名、联合类型、交叉类型、但不支持继承和自动合并&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://juseyanwu.github.io/images/image-20250206032452737.png" alt="images-20250206032452737">&lt;/p>
&lt;p>这个就是type 定义 &lt;strong>类型别名&lt;/strong> 的例子&lt;/p>
&lt;p>&lt;img src="https://juseyanwu.github.io/images/image-20250206032531008.png" alt="images-20250206032531008">&lt;/p>
&lt;p>Type支持&lt;strong>联合类型&lt;/strong> 和 &lt;strong>交叉类型&lt;/strong>&lt;/p>
&lt;h3 id="interface和抽象类的区别">interface和抽象类的区别&lt;/h3>
&lt;ul>
&lt;li>相同点： 都用于定义一个类的格式&lt;/li>
&lt;li>不同点：
&lt;ul>
&lt;li>接口：只能描述结构，不能有任何的代码实现，一个类可以实现多个接口&lt;/li>
&lt;li>抽象类： 既可以包含抽象方法，也可以包含具体方法，一个类只能继承一个抽象类&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://juseyanwu.github.io/images/image-20250206033009028.png" alt="images-20250206033009028">&lt;/p>
&lt;p>这是一个类能实现多个接口的例子&lt;/p>
&lt;h2 id="泛型">泛型&lt;/h2>
&lt;p>泛型允许我们在定义函数，类或接口时，使用类型参数来表示未指定的类型，这些参数在具体使用时，才被指定具体的类型，泛型能让同一段代码适用于多种类型，同时仍然保持类型的安全性&lt;/p>
&lt;p>&lt;img src="https://juseyanwu.github.io/images/image-20250206033404133.png" alt="images-20250206033404133">&lt;/p>
&lt;p>&lt;img src="https://juseyanwu.github.io/images/image-20250206033449756.png" alt="images-20250206033449756">&lt;/p>
&lt;p>也可以多个&lt;/p>
&lt;h3 id="泛型接口">泛型接口&lt;/h3>
&lt;p>&lt;img src="https://juseyanwu.github.io/images/image-20250206033545753.png" alt="images-20250206033545753">&lt;/p>
&lt;p>&lt;img src="https://juseyanwu.github.io/images/image-20250206033640780.png" alt="images-20250206033640780">&lt;/p>
&lt;h3 id="类型声明文件">类型声明文件&lt;/h3>
&lt;p>通常以.d.ts结尾&lt;/p>
&lt;p>作用是为 &lt;strong>现有的js代码提供类型信息&lt;/strong>&lt;/p>
&lt;p>使得ts在使用这些老的js库或者模块时进行&lt;strong>类型检查和提示&lt;/strong>&lt;/p></description></item></channel></rss>